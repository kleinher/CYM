
SensorHumedad.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000c8  00800100  00000438  000004cc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000438  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000009  008001c8  008001c8  00000594  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000594  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000005c4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000150  00000000  00000000  00000604  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000155b  00000000  00000000  00000754  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000b56  00000000  00000000  00001caf  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000a3e  00000000  00000000  00002805  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000002d0  00000000  00000000  00003244  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000075b  00000000  00000000  00003514  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000007ee  00000000  00000000  00003c6f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000110  00000000  00000000  0000445d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__vector_16>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e8 e3       	ldi	r30, 0x38	; 56
  7c:	f4 e0       	ldi	r31, 0x04	; 4
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a8 3c       	cpi	r26, 0xC8	; 200
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	21 e0       	ldi	r18, 0x01	; 1
  8c:	a8 ec       	ldi	r26, 0xC8	; 200
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a1 3d       	cpi	r26, 0xD1	; 209
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 7b 00 	call	0xf6	; 0xf6 <main>
  9e:	0c 94 1a 02 	jmp	0x434	; 0x434 <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <setupTimer>:
#include <avr/interrupt.h>
#include "main.h"
extern volatile int checkSensorHumidity;

void setupTimer(){
	TCCR0B=(1<<CS02)|(1<<CS00); //configurar el registro del timer0 como temporizador con prescalador de 1024
  a6:	85 e0       	ldi	r24, 0x05	; 5
  a8:	85 bd       	out	0x25, r24	; 37
	TCNT0=99;					//el registro empieza con valor 99
  aa:	83 e6       	ldi	r24, 0x63	; 99
  ac:	86 bd       	out	0x26, r24	; 38
	TIMSK0|= (1<<TOIE0);	    //habilita la interrupcion por desbordamiento del timer0
  ae:	ee e6       	ldi	r30, 0x6E	; 110
  b0:	f0 e0       	ldi	r31, 0x00	; 0
  b2:	80 81       	ld	r24, Z
  b4:	81 60       	ori	r24, 0x01	; 1
  b6:	80 83       	st	Z, r24
	sei();				        //habilita interrupciones globales
  b8:	78 94       	sei
  ba:	08 95       	ret

000000bc <__vector_16>:
}

ISR(TIMER0_OVF_vect)
{
  bc:	1f 92       	push	r1
  be:	0f 92       	push	r0
  c0:	0f b6       	in	r0, 0x3f	; 63
  c2:	0f 92       	push	r0
  c4:	11 24       	eor	r1, r1
  c6:	8f 93       	push	r24
	uint8_t static cont=0;
	cont++;
  c8:	80 91 c8 01 	lds	r24, 0x01C8	; 0x8001c8 <__data_end>
  cc:	8f 5f       	subi	r24, 0xFF	; 255
  ce:	80 93 c8 01 	sts	0x01C8, r24	; 0x8001c8 <__data_end>
	TCNT0=99;//reinicio contador del timer0
  d2:	83 e6       	ldi	r24, 0x63	; 99
  d4:	86 bd       	out	0x26, r24	; 38
	if(cont==100){
  d6:	80 91 c8 01 	lds	r24, 0x01C8	; 0x8001c8 <__data_end>
  da:	84 36       	cpi	r24, 0x64	; 100
  dc:	31 f4       	brne	.+12     	; 0xea <__vector_16+0x2e>
		checkSensorHumidity = false;
  de:	10 92 cb 01 	sts	0x01CB, r1	; 0x8001cb <checkSensorHumidity+0x1>
  e2:	10 92 ca 01 	sts	0x01CA, r1	; 0x8001ca <checkSensorHumidity>
		cont=0;//reinicio contador
  e6:	10 92 c8 01 	sts	0x01C8, r1	; 0x8001c8 <__data_end>
	}
	
  ea:	8f 91       	pop	r24
  ec:	0f 90       	pop	r0
  ee:	0f be       	out	0x3f, r0	; 63
  f0:	0f 90       	pop	r0
  f2:	1f 90       	pop	r1
  f4:	18 95       	reti

000000f6 <main>:
 #include <util/delay.h>
 #include "main.h"
  volatile int checkSensorHumidity;
int main(void)
{
	checkSensorHumidity = true;
  f6:	81 e0       	ldi	r24, 0x01	; 1
  f8:	90 e0       	ldi	r25, 0x00	; 0
  fa:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <checkSensorHumidity+0x1>
  fe:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <checkSensorHumidity>
	setupTimer();
 102:	0e 94 53 00 	call	0xa6	; 0xa6 <setupTimer>
	SerialPort_Init(103);
 106:	87 e6       	ldi	r24, 0x67	; 103
 108:	0e 94 93 01 	call	0x326	; 0x326 <SerialPort_Init>
	SerialPort_TX_Enable();
 10c:	0e 94 9b 01 	call	0x336	; 0x336 <SerialPort_TX_Enable>
	SerialPort_RX_Enable();
 110:	0e 94 a2 01 	call	0x344	; 0x344 <SerialPort_RX_Enable>
	displayMenu();
 114:	0e 94 d4 01 	call	0x3a8	; 0x3a8 <displayMenu>
	while(1)
	{
		char arreglo[4] ="";
		int i = 0;
		int cont = 1;
		char test = SerialPort_Recive_Data();
 118:	0e 94 d1 01 	call	0x3a2	; 0x3a2 <SerialPort_Recive_Data>
	displayMenu();
	while(1)
	{
		char arreglo[4] ="";
		int i = 0;
		int cont = 1;
 11c:	01 e0       	ldi	r16, 0x01	; 1
 11e:	10 e0       	ldi	r17, 0x00	; 0
	SerialPort_RX_Enable();
	displayMenu();
	while(1)
	{
		char arreglo[4] ="";
		int i = 0;
 120:	c0 e0       	ldi	r28, 0x00	; 0
 122:	d0 e0       	ldi	r29, 0x00	; 0
		int cont = 1;
		char test = SerialPort_Recive_Data();
		while(test != '\r' && i < 4){
 124:	0c c0       	rjmp	.+24     	; 0x13e <main+0x48>
			arreglo[i] = test;
			if(cont == 1 ){
 126:	01 30       	cpi	r16, 0x01	; 1
 128:	11 05       	cpc	r17, r1
 12a:	21 f4       	brne	.+8      	; 0x134 <main+0x3e>
					SerialPort_Send_Data(test);
 12c:	0e 94 ad 01 	call	0x35a	; 0x35a <SerialPort_Send_Data>
					cont = 0;
 130:	00 e0       	ldi	r16, 0x00	; 0
 132:	10 e0       	ldi	r17, 0x00	; 0
			}
			
			 i++;
 134:	21 96       	adiw	r28, 0x01	; 1
			 SerialPort_Wait_Until_New_Data();
 136:	0e 94 cc 01 	call	0x398	; 0x398 <SerialPort_Wait_Until_New_Data>
			 test = SerialPort_Recive_Data();
 13a:	0e 94 d1 01 	call	0x3a2	; 0x3a2 <SerialPort_Recive_Data>
	{
		char arreglo[4] ="";
		int i = 0;
		int cont = 1;
		char test = SerialPort_Recive_Data();
		while(test != '\r' && i < 4){
 13e:	8d 30       	cpi	r24, 0x0D	; 13
 140:	19 f0       	breq	.+6      	; 0x148 <main+0x52>
 142:	c4 30       	cpi	r28, 0x04	; 4
 144:	d1 05       	cpc	r29, r1
 146:	7c f3       	brlt	.-34     	; 0x126 <main+0x30>
			 test = SerialPort_Recive_Data();
			 
		}
		
		
		if(checkSensorHumidity){
 148:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <checkSensorHumidity>
 14c:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <checkSensorHumidity+0x1>
 150:	89 2b       	or	r24, r25
 152:	11 f3       	breq	.-60     	; 0x118 <main+0x22>
			updateHumidity();
 154:	0e 94 fd 00 	call	0x1fa	; 0x1fa <updateHumidity>
			checkSensorHumidity = false;
 158:	10 92 cb 01 	sts	0x01CB, r1	; 0x8001cb <checkSensorHumidity+0x1>
 15c:	10 92 ca 01 	sts	0x01CA, r1	; 0x8001ca <checkSensorHumidity>
		}
	}
 160:	db cf       	rjmp	.-74     	; 0x118 <main+0x22>

00000162 <Request>:
 uint8_t I_RH,D_RH,I_Temp,D_Temp,CheckSum;
 uint8_t c=0;

void Request()				/* Microcontroller send start pulse/request */
{
	DDRD |= (1<<DHT11_PIN);
 162:	8a b1       	in	r24, 0x0a	; 10
 164:	80 64       	ori	r24, 0x40	; 64
 166:	8a b9       	out	0x0a, r24	; 10
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 168:	2f ef       	ldi	r18, 0xFF	; 255
 16a:	89 ef       	ldi	r24, 0xF9	; 249
 16c:	90 e0       	ldi	r25, 0x00	; 0
 16e:	21 50       	subi	r18, 0x01	; 1
 170:	80 40       	sbci	r24, 0x00	; 0
 172:	90 40       	sbci	r25, 0x00	; 0
 174:	e1 f7       	brne	.-8      	; 0x16e <Request+0xc>
 176:	00 c0       	rjmp	.+0      	; 0x178 <Request+0x16>
 178:	00 00       	nop
	_delay_ms(20);	
	PORTD &= ~(1<<DHT11_PIN);	/* set to low pin */
 17a:	8b b1       	in	r24, 0x0b	; 11
 17c:	8f 7b       	andi	r24, 0xBF	; 191
 17e:	8b b9       	out	0x0b, r24	; 11
 180:	2f ef       	ldi	r18, 0xFF	; 255
 182:	89 ef       	ldi	r24, 0xF9	; 249
 184:	90 e0       	ldi	r25, 0x00	; 0
 186:	21 50       	subi	r18, 0x01	; 1
 188:	80 40       	sbci	r24, 0x00	; 0
 18a:	90 40       	sbci	r25, 0x00	; 0
 18c:	e1 f7       	brne	.-8      	; 0x186 <Request+0x24>
 18e:	00 c0       	rjmp	.+0      	; 0x190 <Request+0x2e>
 190:	00 00       	nop
	_delay_ms(20);			/* wait for 20ms */
	PORTD |= (1<<DHT11_PIN);	/* set to high pin */
 192:	8b b1       	in	r24, 0x0b	; 11
 194:	80 64       	ori	r24, 0x40	; 64
 196:	8b b9       	out	0x0b, r24	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 198:	25 ed       	ldi	r18, 0xD5	; 213
 19a:	2a 95       	dec	r18
 19c:	f1 f7       	brne	.-4      	; 0x19a <Request+0x38>
 19e:	00 00       	nop
 1a0:	08 95       	ret

000001a2 <Response>:
	_delay_us(40);	
}

void Response()				/* receive response from DHT11 */
{
	DDRD &= ~(1<<DHT11_PIN);
 1a2:	8a b1       	in	r24, 0x0a	; 10
 1a4:	8f 7b       	andi	r24, 0xBF	; 191
 1a6:	8a b9       	out	0x0a, r24	; 10
	while(PIND & (1<<DHT11_PIN));//Limpia el 1 de la salida nuestra
 1a8:	4e 99       	sbic	0x09, 6	; 9
 1aa:	fe cf       	rjmp	.-4      	; 0x1a8 <Response+0x6>
	
	while((PIND & (1<<DHT11_PIN))==0); //limpia el 1 del sensor
 1ac:	4e 9b       	sbis	0x09, 6	; 9
 1ae:	fe cf       	rjmp	.-4      	; 0x1ac <Response+0xa>
	
	while(PIND & (1<<DHT11_PIN));//limpia el 0 del sensor
 1b0:	4e 99       	sbic	0x09, 6	; 9
 1b2:	fe cf       	rjmp	.-4      	; 0x1b0 <Response+0xe>
}
 1b4:	08 95       	ret

000001b6 <Receive_data>:

uint8_t Receive_data()			/* receive data */
{	
	for (int q=0; q<8; q++)
 1b6:	20 e0       	ldi	r18, 0x00	; 0
 1b8:	30 e0       	ldi	r19, 0x00	; 0
 1ba:	19 c0       	rjmp	.+50     	; 0x1ee <Receive_data+0x38>
	{
		while((PIND & (1<<DHT11_PIN)) == 0);  /* check received bit 0 or 1 */
 1bc:	4e 9b       	sbis	0x09, 6	; 9
 1be:	fe cf       	rjmp	.-4      	; 0x1bc <Receive_data+0x6>
 1c0:	80 ea       	ldi	r24, 0xA0	; 160
 1c2:	8a 95       	dec	r24
 1c4:	f1 f7       	brne	.-4      	; 0x1c2 <Receive_data+0xc>
		_delay_us(30);
		if(PIND & (1<<DHT11_PIN))/* if high pulse is greater than 30ms */
 1c6:	4e 9b       	sbis	0x09, 6	; 9
 1c8:	09 c0       	rjmp	.+18     	; 0x1dc <Receive_data+0x26>
		c = (c<<1)|(0x01);	/* then its logic HIGH */
 1ca:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <c>
 1ce:	90 e0       	ldi	r25, 0x00	; 0
 1d0:	88 0f       	add	r24, r24
 1d2:	99 1f       	adc	r25, r25
 1d4:	81 60       	ori	r24, 0x01	; 1
 1d6:	80 93 c9 01 	sts	0x01C9, r24	; 0x8001c9 <c>
 1da:	05 c0       	rjmp	.+10     	; 0x1e6 <Receive_data+0x30>
		else			/* otherwise its logic LOW */
		c = (c<<1);
 1dc:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <c>
 1e0:	88 0f       	add	r24, r24
 1e2:	80 93 c9 01 	sts	0x01C9, r24	; 0x8001c9 <c>
		while(PIND & (1<<DHT11_PIN));
 1e6:	4e 99       	sbic	0x09, 6	; 9
 1e8:	fe cf       	rjmp	.-4      	; 0x1e6 <Receive_data+0x30>
	while(PIND & (1<<DHT11_PIN));//limpia el 0 del sensor
}

uint8_t Receive_data()			/* receive data */
{	
	for (int q=0; q<8; q++)
 1ea:	2f 5f       	subi	r18, 0xFF	; 255
 1ec:	3f 4f       	sbci	r19, 0xFF	; 255
 1ee:	28 30       	cpi	r18, 0x08	; 8
 1f0:	31 05       	cpc	r19, r1
 1f2:	24 f3       	brlt	.-56     	; 0x1bc <Receive_data+0x6>
		else			/* otherwise its logic LOW */
		c = (c<<1);
		while(PIND & (1<<DHT11_PIN));
	}
	return c;
}
 1f4:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <c>
 1f8:	08 95       	ret

000001fa <updateHumidity>:

void updateHumidity(){
 1fa:	cf 93       	push	r28
 1fc:	df 93       	push	r29
 1fe:	00 d0       	rcall	.+0      	; 0x200 <updateHumidity+0x6>
 200:	00 d0       	rcall	.+0      	; 0x202 <updateHumidity+0x8>
 202:	1f 92       	push	r1
 204:	cd b7       	in	r28, 0x3d	; 61
 206:	de b7       	in	r29, 0x3e	; 62
	char data[5];
	
	 Request();
 208:	0e 94 b1 00 	call	0x162	; 0x162 <Request>
	 /* Microcontroller send start pulse/request */
	 Response();		// receive response
 20c:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <Response>
	 I_RH=Receive_data();	// store first eight bit in I_RH
 210:	0e 94 db 00 	call	0x1b6	; 0x1b6 <Receive_data>
 214:	80 93 cf 01 	sts	0x01CF, r24	; 0x8001cf <I_RH>
	 D_RH=Receive_data();	// store next eight bit in D_RH
 218:	0e 94 db 00 	call	0x1b6	; 0x1b6 <Receive_data>
 21c:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <D_RH>
	 I_Temp=Receive_data();	// store next eight bit in I_Temp
 220:	0e 94 db 00 	call	0x1b6	; 0x1b6 <Receive_data>
 224:	80 93 ce 01 	sts	0x01CE, r24	; 0x8001ce <I_Temp>
	 D_Temp=Receive_data();	// store next eight bit in D_Temp
 228:	0e 94 db 00 	call	0x1b6	; 0x1b6 <Receive_data>
 22c:	80 93 d0 01 	sts	0x01D0, r24	; 0x8001d0 <D_Temp>
	 CheckSum=Receive_data();// store next eight bit in CheckSum
 230:	0e 94 db 00 	call	0x1b6	; 0x1b6 <Receive_data>
 234:	80 93 cd 01 	sts	0x01CD, r24	; 0x8001cd <CheckSum>
	 
	 if ((I_RH + D_RH + I_Temp + D_Temp) != CheckSum)
 238:	90 91 cf 01 	lds	r25, 0x01CF	; 0x8001cf <I_RH>
 23c:	20 91 cc 01 	lds	r18, 0x01CC	; 0x8001cc <D_RH>
 240:	30 e0       	ldi	r19, 0x00	; 0
 242:	29 0f       	add	r18, r25
 244:	31 1d       	adc	r19, r1
 246:	90 91 ce 01 	lds	r25, 0x01CE	; 0x8001ce <I_Temp>
 24a:	29 0f       	add	r18, r25
 24c:	31 1d       	adc	r19, r1
 24e:	90 91 d0 01 	lds	r25, 0x01D0	; 0x8001d0 <D_Temp>
 252:	29 0f       	add	r18, r25
 254:	31 1d       	adc	r19, r1
 256:	90 e0       	ldi	r25, 0x00	; 0
 258:	28 17       	cp	r18, r24
 25a:	39 07       	cpc	r19, r25
 25c:	29 f0       	breq	.+10     	; 0x268 <updateHumidity+0x6e>
	 {
		 SerialPort_Send_String("ERROR EN EL SENSOR DE HUMEDAD!!!!");
 25e:	80 e0       	ldi	r24, 0x00	; 0
 260:	91 e0       	ldi	r25, 0x01	; 1
 262:	0e 94 b0 01 	call	0x360	; 0x360 <SerialPort_Send_String>
 266:	57 c0       	rjmp	.+174    	; 0x316 <updateHumidity+0x11c>
	 }
	 else
	 {
		 test();
 268:	0e 94 a1 01 	call	0x342	; 0x342 <test>
		 itoa(I_RH,data,10);
 26c:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <I_RH>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
 270:	4a e0       	ldi	r20, 0x0A	; 10
 272:	be 01       	movw	r22, r28
 274:	6f 5f       	subi	r22, 0xFF	; 255
 276:	7f 4f       	sbci	r23, 0xFF	; 255
 278:	90 e0       	ldi	r25, 0x00	; 0
 27a:	0e 94 e5 01 	call	0x3ca	; 0x3ca <__itoa_ncheck>
		 SerialPort_Send_String("Humedad: ");
 27e:	82 e2       	ldi	r24, 0x22	; 34
 280:	91 e0       	ldi	r25, 0x01	; 1
 282:	0e 94 b0 01 	call	0x360	; 0x360 <SerialPort_Send_String>
		 SerialPort_Send_String(data);
 286:	ce 01       	movw	r24, r28
 288:	01 96       	adiw	r24, 0x01	; 1
 28a:	0e 94 b0 01 	call	0x360	; 0x360 <SerialPort_Send_String>
		 SerialPort_Send_String(".");
 28e:	8c e2       	ldi	r24, 0x2C	; 44
 290:	91 e0       	ldi	r25, 0x01	; 1
 292:	0e 94 b0 01 	call	0x360	; 0x360 <SerialPort_Send_String>
		 itoa(D_RH,data,10);
 296:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <D_RH>
 29a:	4a e0       	ldi	r20, 0x0A	; 10
 29c:	be 01       	movw	r22, r28
 29e:	6f 5f       	subi	r22, 0xFF	; 255
 2a0:	7f 4f       	sbci	r23, 0xFF	; 255
 2a2:	90 e0       	ldi	r25, 0x00	; 0
 2a4:	0e 94 e5 01 	call	0x3ca	; 0x3ca <__itoa_ncheck>
		 SerialPort_Send_String(data);
 2a8:	ce 01       	movw	r24, r28
 2aa:	01 96       	adiw	r24, 0x01	; 1
 2ac:	0e 94 b0 01 	call	0x360	; 0x360 <SerialPort_Send_String>
		 SerialPort_Send_String("\r\n");
 2b0:	8e e2       	ldi	r24, 0x2E	; 46
 2b2:	91 e0       	ldi	r25, 0x01	; 1
 2b4:	0e 94 b0 01 	call	0x360	; 0x360 <SerialPort_Send_String>
		 SerialPort_Send_String("Temperatura: ");
 2b8:	81 e3       	ldi	r24, 0x31	; 49
 2ba:	91 e0       	ldi	r25, 0x01	; 1
 2bc:	0e 94 b0 01 	call	0x360	; 0x360 <SerialPort_Send_String>
		 itoa(I_Temp,data,10);
 2c0:	80 91 ce 01 	lds	r24, 0x01CE	; 0x8001ce <I_Temp>
 2c4:	4a e0       	ldi	r20, 0x0A	; 10
 2c6:	be 01       	movw	r22, r28
 2c8:	6f 5f       	subi	r22, 0xFF	; 255
 2ca:	7f 4f       	sbci	r23, 0xFF	; 255
 2cc:	90 e0       	ldi	r25, 0x00	; 0
 2ce:	0e 94 e5 01 	call	0x3ca	; 0x3ca <__itoa_ncheck>
		 SerialPort_Send_String(data);
 2d2:	ce 01       	movw	r24, r28
 2d4:	01 96       	adiw	r24, 0x01	; 1
 2d6:	0e 94 b0 01 	call	0x360	; 0x360 <SerialPort_Send_String>
		 SerialPort_Send_String(".");
 2da:	8c e2       	ldi	r24, 0x2C	; 44
 2dc:	91 e0       	ldi	r25, 0x01	; 1
 2de:	0e 94 b0 01 	call	0x360	; 0x360 <SerialPort_Send_String>
		 itoa(D_Temp,data,10);
 2e2:	80 91 d0 01 	lds	r24, 0x01D0	; 0x8001d0 <D_Temp>
 2e6:	4a e0       	ldi	r20, 0x0A	; 10
 2e8:	be 01       	movw	r22, r28
 2ea:	6f 5f       	subi	r22, 0xFF	; 255
 2ec:	7f 4f       	sbci	r23, 0xFF	; 255
 2ee:	90 e0       	ldi	r25, 0x00	; 0
 2f0:	0e 94 e5 01 	call	0x3ca	; 0x3ca <__itoa_ncheck>
		 SerialPort_Send_String(data);
 2f4:	ce 01       	movw	r24, r28
 2f6:	01 96       	adiw	r24, 0x01	; 1
 2f8:	0e 94 b0 01 	call	0x360	; 0x360 <SerialPort_Send_String>
		 SerialPort_Send_String("\r\n");
 2fc:	8e e2       	ldi	r24, 0x2E	; 46
 2fe:	91 e0       	ldi	r25, 0x01	; 1
 300:	0e 94 b0 01 	call	0x360	; 0x360 <SerialPort_Send_String>
		 itoa(CheckSum,data,10);
 304:	80 91 cd 01 	lds	r24, 0x01CD	; 0x8001cd <CheckSum>
 308:	4a e0       	ldi	r20, 0x0A	; 10
 30a:	be 01       	movw	r22, r28
 30c:	6f 5f       	subi	r22, 0xFF	; 255
 30e:	7f 4f       	sbci	r23, 0xFF	; 255
 310:	90 e0       	ldi	r25, 0x00	; 0
 312:	0e 94 e5 01 	call	0x3ca	; 0x3ca <__itoa_ncheck>
	
	 }
	 }
 316:	0f 90       	pop	r0
 318:	0f 90       	pop	r0
 31a:	0f 90       	pop	r0
 31c:	0f 90       	pop	r0
 31e:	0f 90       	pop	r0
 320:	df 91       	pop	r29
 322:	cf 91       	pop	r28
 324:	08 95       	ret

00000326 <SerialPort_Init>:
	if ( (UCSR0A & (1<<RXC0))==1) {
		*dato=UDR0;
		return 1;
	}
	return 0; //no data
}
 326:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
 32a:	96 e0       	ldi	r25, 0x06	; 6
 32c:	90 93 c2 00 	sts	0x00C2, r25	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
 330:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
 334:	08 95       	ret

00000336 <SerialPort_TX_Enable>:
 336:	e1 ec       	ldi	r30, 0xC1	; 193
 338:	f0 e0       	ldi	r31, 0x00	; 0
 33a:	80 81       	ld	r24, Z
 33c:	88 60       	ori	r24, 0x08	; 8
 33e:	80 83       	st	Z, r24
 340:	08 95       	ret

00000342 <test>:
 342:	08 95       	ret

00000344 <SerialPort_RX_Enable>:
 344:	e1 ec       	ldi	r30, 0xC1	; 193
 346:	f0 e0       	ldi	r31, 0x00	; 0
 348:	80 81       	ld	r24, Z
 34a:	80 61       	ori	r24, 0x10	; 16
 34c:	80 83       	st	Z, r24
 34e:	08 95       	ret

00000350 <SerialPort_Wait_For_TX_Buffer_Free>:
 350:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
 354:	85 ff       	sbrs	r24, 5
 356:	fc cf       	rjmp	.-8      	; 0x350 <SerialPort_Wait_For_TX_Buffer_Free>
 358:	08 95       	ret

0000035a <SerialPort_Send_Data>:
 35a:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
 35e:	08 95       	ret

00000360 <SerialPort_Send_String>:
 360:	ef 92       	push	r14
 362:	ff 92       	push	r15
 364:	0f 93       	push	r16
 366:	1f 93       	push	r17
 368:	cf 93       	push	r28
 36a:	7c 01       	movw	r14, r24
 36c:	c0 e0       	ldi	r28, 0x00	; 0
 36e:	07 c0       	rjmp	.+14     	; 0x37e <SerialPort_Send_String+0x1e>
 370:	0e 94 a8 01 	call	0x350	; 0x350 <SerialPort_Wait_For_TX_Buffer_Free>
 374:	f8 01       	movw	r30, r16
 376:	80 81       	ld	r24, Z
 378:	0e 94 ad 01 	call	0x35a	; 0x35a <SerialPort_Send_Data>
 37c:	cf 5f       	subi	r28, 0xFF	; 255
 37e:	87 01       	movw	r16, r14
 380:	0c 0f       	add	r16, r28
 382:	11 1d       	adc	r17, r1
 384:	f8 01       	movw	r30, r16
 386:	80 81       	ld	r24, Z
 388:	81 11       	cpse	r24, r1
 38a:	f2 cf       	rjmp	.-28     	; 0x370 <SerialPort_Send_String+0x10>
 38c:	cf 91       	pop	r28
 38e:	1f 91       	pop	r17
 390:	0f 91       	pop	r16
 392:	ff 90       	pop	r15
 394:	ef 90       	pop	r14
 396:	08 95       	ret

00000398 <SerialPort_Wait_Until_New_Data>:
 398:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
 39c:	88 23       	and	r24, r24
 39e:	e4 f7       	brge	.-8      	; 0x398 <SerialPort_Wait_Until_New_Data>
 3a0:	08 95       	ret

000003a2 <SerialPort_Recive_Data>:
 3a2:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
 3a6:	08 95       	ret

000003a8 <displayMenu>:



void displayMenu(){
		 SerialPort_Send_String("Menu \n\r");
 3a8:	8f e3       	ldi	r24, 0x3F	; 63
 3aa:	91 e0       	ldi	r25, 0x01	; 1
 3ac:	0e 94 b0 01 	call	0x360	; 0x360 <SerialPort_Send_String>
		 SerialPort_Send_String("1. 'ON'<Enter>  - encender registrador \n\r");
 3b0:	87 e4       	ldi	r24, 0x47	; 71
 3b2:	91 e0       	ldi	r25, 0x01	; 1
 3b4:	0e 94 b0 01 	call	0x360	; 0x360 <SerialPort_Send_String>
		 SerialPort_Send_String("2. 'OFF'<Enter> - apagar registrador \n\r");
 3b8:	81 e7       	ldi	r24, 0x71	; 113
 3ba:	91 e0       	ldi	r25, 0x01	; 1
 3bc:	0e 94 b0 01 	call	0x360	; 0x360 <SerialPort_Send_String>
		 SerialPort_Send_String("3. 'RST'<Enter> - Volver al estado inicial \n\r");
 3c0:	89 e9       	ldi	r24, 0x99	; 153
 3c2:	91 e0       	ldi	r25, 0x01	; 1
 3c4:	0e 94 b0 01 	call	0x360	; 0x360 <SerialPort_Send_String>
 3c8:	08 95       	ret

000003ca <__itoa_ncheck>:
 3ca:	bb 27       	eor	r27, r27
 3cc:	4a 30       	cpi	r20, 0x0A	; 10
 3ce:	31 f4       	brne	.+12     	; 0x3dc <__itoa_ncheck+0x12>
 3d0:	99 23       	and	r25, r25
 3d2:	22 f4       	brpl	.+8      	; 0x3dc <__itoa_ncheck+0x12>
 3d4:	bd e2       	ldi	r27, 0x2D	; 45
 3d6:	90 95       	com	r25
 3d8:	81 95       	neg	r24
 3da:	9f 4f       	sbci	r25, 0xFF	; 255
 3dc:	0c 94 f1 01 	jmp	0x3e2	; 0x3e2 <__utoa_common>

000003e0 <__utoa_ncheck>:
 3e0:	bb 27       	eor	r27, r27

000003e2 <__utoa_common>:
 3e2:	fb 01       	movw	r30, r22
 3e4:	55 27       	eor	r21, r21
 3e6:	aa 27       	eor	r26, r26
 3e8:	88 0f       	add	r24, r24
 3ea:	99 1f       	adc	r25, r25
 3ec:	aa 1f       	adc	r26, r26
 3ee:	a4 17       	cp	r26, r20
 3f0:	10 f0       	brcs	.+4      	; 0x3f6 <__utoa_common+0x14>
 3f2:	a4 1b       	sub	r26, r20
 3f4:	83 95       	inc	r24
 3f6:	50 51       	subi	r21, 0x10	; 16
 3f8:	b9 f7       	brne	.-18     	; 0x3e8 <__utoa_common+0x6>
 3fa:	a0 5d       	subi	r26, 0xD0	; 208
 3fc:	aa 33       	cpi	r26, 0x3A	; 58
 3fe:	08 f0       	brcs	.+2      	; 0x402 <__EEPROM_REGION_LENGTH__+0x2>
 400:	a9 5d       	subi	r26, 0xD9	; 217
 402:	a1 93       	st	Z+, r26
 404:	00 97       	sbiw	r24, 0x00	; 0
 406:	79 f7       	brne	.-34     	; 0x3e6 <__utoa_common+0x4>
 408:	b1 11       	cpse	r27, r1
 40a:	b1 93       	st	Z+, r27
 40c:	11 92       	st	Z+, r1
 40e:	cb 01       	movw	r24, r22
 410:	0c 94 0a 02 	jmp	0x414	; 0x414 <strrev>

00000414 <strrev>:
 414:	dc 01       	movw	r26, r24
 416:	fc 01       	movw	r30, r24
 418:	67 2f       	mov	r22, r23
 41a:	71 91       	ld	r23, Z+
 41c:	77 23       	and	r23, r23
 41e:	e1 f7       	brne	.-8      	; 0x418 <strrev+0x4>
 420:	32 97       	sbiw	r30, 0x02	; 2
 422:	04 c0       	rjmp	.+8      	; 0x42c <strrev+0x18>
 424:	7c 91       	ld	r23, X
 426:	6d 93       	st	X+, r22
 428:	70 83       	st	Z, r23
 42a:	62 91       	ld	r22, -Z
 42c:	ae 17       	cp	r26, r30
 42e:	bf 07       	cpc	r27, r31
 430:	c8 f3       	brcs	.-14     	; 0x424 <strrev+0x10>
 432:	08 95       	ret

00000434 <_exit>:
 434:	f8 94       	cli

00000436 <__stop_program>:
 436:	ff cf       	rjmp	.-2      	; 0x436 <__stop_program>
